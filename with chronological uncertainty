approxfun                package:stats                 R Documentation

_I_n_t_e_r_p_o_l_a_t_i_o_n _F_u_n_c_t_i_o_n_s

_D_e_s_c_r_i_p_t_i_o_n:

     Return a list of points which linearly interpolate given data
     points, or a function performing the linear (or constant)
     interpolation.

_U_s_a_g_e:

     approx   (x, y = NULL, xout, method = "linear", n = 50,
               yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE)
     
     approxfun(x, y = NULL,       method = "linear",
               yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE)
     
_A_r_g_u_m_e_n_t_s:

    x, y: numeric vectors giving the coordinates of the points to be
          interpolated.  Alternatively a single plotting structure can
          be specified: see ‘xy.coords’.

    xout: an optional set of numeric values specifying where
          interpolation is to take place.

  method: specifies the interpolation method to be used.  Choices are
          ‘"linear"’ or ‘"constant"’.

       n: If ‘xout’ is not specified, interpolation takes place at ‘n’
          equally spaced points spanning the interval [‘min(x)’,
          ‘max(x)’].

   yleft: the value to be returned when input ‘x’ values are less than
          ‘min(x)’. The default is defined by the value of ‘rule’ given
          below.

  yright: the value to be returned when input ‘x’ values are greater
          than ‘max(x)’. The default is defined by the value of ‘rule’
          given below.

    rule: an integer (of length 1 or 2) describing how interpolation is
          to take place outside the interval [‘min(x)’, ‘max(x)’].  If
          ‘rule’ is ‘1’ then ‘NA’s are returned for such points and if
          it is ‘2’, the value at the closest data extreme is used.
          Use, e.g., ‘rule = 2:1’, if the left and right side
          extrapolation should differ.

       f: for ‘method = "constant"’ a number between 0 and 1 inclusive,
          indicating a compromise between left- and right-continuous
          step functions. If ‘y0’ and ‘y1’ are the values to the left
          and right of the point then the value is ‘y0’ if ‘f == 0’,
          ‘y1’ if ‘f == 1’, and ‘ y0*(1-f)+y1*f’ for intermediate
          values. In this way the result is right-continuous for ‘f ==
          0’ and left-continuous for ‘f == 1’, even for non-finite ‘y’
          values.

    ties: handling of tied ‘x’ values.  The string ‘"ordered"’ or a
          function (or the name of a function) taking a single vector
          argument and returning a single number or a ‘list’ of both,
          e.g., ‘list("ordered", mean)’, see ‘Details’.

   na.rm: logical specifying how missing values (‘NA’'s) should be
          handled.  Setting ‘na.rm=FALSE’ will propagate ‘NA’'s in ‘y’
          to the interpolated values, also depending on the ‘rule’ set.
          Note that in this case, ‘NA’'s in ‘x’ are invalid, see also
          the examples.

_D_e_t_a_i_l_s:

     The inputs can contain missing values which are deleted (if
     ‘na.rm’ is true, i.e., by default), so at least two complete ‘(x,
     y)’ pairs are required (for ‘method = "linear"’, one otherwise).
     If there are duplicated (tied) ‘x’ values and ‘ties’ contains a
     function it is applied to the ‘y’ values for each distinct ‘x’
     value to produce ‘(x,y)’ pairs with unique ‘x’.  Useful functions
     in this context include ‘mean’, ‘min’, and ‘max’.

     If ‘ties = "ordered"’ the ‘x’ values are assumed to be already
     ordered (and unique) and ties are _not_ checked but kept if
     present.  This is the fastest option for large ‘length(x)’.

     If ‘ties’ is a ‘list’ of length two, ‘ties[[2]]’ must be a
     function to be applied to ties, see above, but if ‘ties[[1]]’ is
     identical to ‘"ordered"’, the ‘x’ values are assumed to be sorted
     and are only checked for ties.  Consequently, ‘ties =
     list("ordered", mean)’ will be slightly more efficient than the
     default ‘ties = mean’ in such a case.

     The first ‘y’ value will be used for interpolation to the left and
     the last one for interpolation to the right.

_V_a_l_u_e:

     ‘approx’ returns a list with components ‘x’ and ‘y’, containing
     ‘n’ coordinates which interpolate the given data points according
     to the ‘method’ (and ‘rule’) desired.

     The function ‘approxfun’ returns a function performing (linear or
     constant) interpolation of the given data points.  For a given set
     of ‘x’ values, this function will return the corresponding
     interpolated values.  It uses data stored in its environment when
     it was created, the details of which are subject to change.

_W_a_r_n_i_n_g:

     The value returned by ‘approxfun’ contains references to the code
     in the current version of R: it is not intended to be saved and
     loaded into a different R session.  This is safer for R >= 3.0.0.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘spline’ and ‘splinefun’ for spline interpolation.

_E_x_a_m_p_l_e_s:

     require(graphics)
     
     x <- 1:10
     y <- rnorm(10)
     par(mfrow = c(2,1))
     plot(x, y, main = "approx(.) and approxfun(.)")
     points(approx(x, y), col = 2, pch = "*")
     points(approx(x, y, method = "constant"), col = 4, pch = "*")
     
     f <- approxfun(x, y)
     curve(f(x), 0, 11, col = "green2")
     points(x, y)
     is.function(fc <- approxfun(x, y, method = "const")) # TRUE
     curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
     ## different extrapolation on left and right side :
     plot(approxfun(x, y, rule = 2:1), 0, 11,
          col = "tomato", add = TRUE, lty = 3, lwd = 2)
     
     ### Treatment of 'NA's -- are kept if  na.rm=FALSE :
     
     xn <- 1:4
     yn <- c(1,NA,3:4)
     xout <- (1:9)/2
     ## Default behavior (na.rm = TRUE): NA's omitted; extrapolation gives NA
     data.frame(approx(xn,yn, xout))
     data.frame(approx(xn,yn, xout, rule = 2))# -> *constant* extrapolation
     ## New (2019-2020)  na.rm = FALSE: NA's are "kept"
     data.frame(approx(xn,yn, xout, na.rm=FALSE, rule = 2))
     data.frame(approx(xn,yn, xout, na.rm=FALSE, rule = 2, method="constant"))
     
     ## NA's in x[] are not allowed:
     stopifnot(inherits( try( approx(yn,yn, na.rm=FALSE) ), "try-error"))
     
     ## Give a nice overview of all possibilities  rule * method * na.rm :
     ##             -----------------------------  ====   ======   =====
     ## extrapolations "N":= NA;   "C":= Constant :
     rules <- list(N=1, C=2, NC=1:2, CN=2:1)
     methods <- c("constant","linear")
     ry <- sapply(rules, function(R) {
            sapply(methods, function(M)
             sapply(setNames(,c(TRUE,FALSE)), function(na.)
                      approx(xn, yn, xout=xout, method=M, rule=R, na.rm=na.)$y),
             simplify="array")
        }, simplify="array")
     names(dimnames(ry)) <- c("x = ", "na.rm", "method", "rule")
     dimnames(ry)[[1]] <- format(xout)
     ftable(aperm(ry, 4:1)) # --> (4 * 2 * 2) x length(xout)  =  16 x 9 matrix
     
     
     ## Show treatment of 'ties' :
     
     x <- c(2,2:4,4,4,5,5,7,7,7)
     y <- c(1:6, 5:4, 3:1)
     (amy <- approx(x, y, xout = x)$y) # warning, can be avoided by specifying 'ties=':
     op <- options(warn=2) # warnings would be error
     stopifnot(identical(amy, approx(x, y, xout = x, ties=mean)$y))
     (ay <- approx(x, y, xout = x, ties = "ordered")$y)
     stopifnot(amy == c(1.5,1.5, 3, 5,5,5, 4.5,4.5, 2,2,2),
               ay  == c(2, 2,    3, 6,6,6, 4, 4,    1,1,1))
     approx(x, y, xout = x, ties = min)$y
     approx(x, y, xout = x, ties = max)$y
     options(op) # revert 'warn'ing level
     

